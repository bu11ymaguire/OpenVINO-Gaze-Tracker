# 바이브 코딩(Vibe Coding) 회고록: OpenVINO 프로젝트

## 1. 개요
*   **프로젝트명**: Intel OpenVINO 기반 얼굴 인식 및 하드웨어 벤치마크
*   **기술 스택**: Python, OpenVINO, OpenCV
*   **목표**: CPU, iGPU, NPU 등 다양한 연산 장치에서의 AI 모델 추론 성능 비교 및 최적화

## 2. 성과: 바이브 코딩의 '명(Light)'
바이브 코딩(AI와의 몰입형 협업)을 통해 다음과 같은 놀라운 생산성을 경험했다.
1.  **압도적인 개발 속도**: OpenVINO와 같은 복잡한 GPGPU 라이브러리의 설정과 기본 파이프라인을 순식간에 구축했다.
2.  **즉각적인 결과물**: 이종 하드웨어(Heterogeneous Hardware) 간의 성능 비교 벤치마크 코드를 빠르게 작성하여, 실행 가능한 형태의 결과물을 바로 확인했다.
3.  **진입 장벽 완화**: 방대한 문서와 API를 일일이 찾아보지 않고도 고성능 추론 코드를 구현할 수 있었다.

## 3. 한계: 바이브 코딩의 '암(Shadow)'
그러나 개발 과정에서 AI가 작성한 코드의 구조적 한계 또한 명확히 드러났다.
1.  **High-Level API 의존**: AI는 종종 문제 해결의 '가장 빠른 길'을 제시하기 위해, 라이브러리에 내장된 고수준(Built-in) 함수나 데모 코드 스타일을 그대로 가져오는 경향이 있다.
2.  **파인튜닝(Fine-tuning)의 어려움**:
    *   주요 전처리(Pre-processing)와 후처리(Post-processing) 로직이 라이브러리 내부 함수로 숨겨져 있는 경우가 많았다.
    *   이로 인해 개발자가 입력 데이터의 미세한 조정이나, 추론 결과의 커스텀 해석을 시도할 때 수정할 지점을 찾기 어려웠다.
3.  **코드 장악력 저하**: '작동하는 코드'를 빠르게 얻었지만, 그 코드가 '어떻게' 작동하는지 뜯어보지 않으면 내부 최적화나 트러블슈팅 단계에서 막막해질 위험이 있다.

## 4. 결론 및 교훈
> **"속도는 AI가 주지만, 디테일은 인간이 챙겨야 한다."**

AI는 훌륭한 '부스터' 역할을 해주지만, 엔지니어링의 깊이(Depth)까지 자동으로 채워주지는 않는다.
*   **향후 방향**: AI가 생성한 코드를 그대로 사용하는 것을 넘어, 해당 코드가 호출하는 하위 API를 분석하고 Low-level로 재구성하는 과정을 거쳐야 한다.
*   **개발자의 역할**: AI가 그려준 큰 그림 안에서, 성능과 유연성을 결정짓는 '디테일'한 붓터치는 여전히 개발자의 몫이다. 특히 GPGPU 프로그래밍처럼 하드웨어 특성을 타는 분야일수록, Built-in 함수 뒤에 숨은 로직을 끄집어내는 집요함이 필요하다.
